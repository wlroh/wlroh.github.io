---
layout: post
title: "원시타입과 참조타입"
date: 2022-02-21 23:11:00 +0530
excerpt: "원시타입과 참조타입은 무엇일까?"
categories: Java
---

자바에서는 데이터 타입이 크게 두가지 `원시 타입(Primitive Type)`과 `참조 타입(Reference Type)`이 있다.

`원시 타입(Primitive Type)`은 쉽게 말해 정수, 실수, 문자, 논리 리터럴등의 **실제 데이터 값을 저장하는 타입**이고,

`참조 타입(Reference Type)`은 객체(Object)의 번지를 참조(주소를 저장)하는 타입으로 **메모리 번지 값을 통해 객체를 참조하는 타입**이다.

### 원시 타입(Primitive Type)

![이미지](https://raw.githubusercontent.com/wlroh/wlroh.github.io/main/assets/images/2022-02-21-java-type-2.png)

### 참조 타입(Reference Type)

`참조 타입`은 **원시 타입을 제외한 타입들(문자열, 배열, 열거, 클래스, 인터페이스)** 을 말한다.

Java에서 `실제 객체`는 `힙 영역`에 **저장** 되며 `참조 타입 변수`는 `스택 영역`에 **실제 객체들의 주소를 저장**하여, 객체를 사용할 때 마다 **참조 변수에 저장된 객체의 주소를 불러와 사용하는 방식** 이다.

```java
public void test() {
  int age = 25;
  char cc = 'c';
  String name = "coffee";
}
```

<br/>

| 스택(Stack) 영역                                             | 힙(Heap) 영역     |
| ------------------------------------------------------------ | ----------------- |
| int age = 25;<br/>char cc = 'c';<br/>String name = 10101번지 | 10101번지: "커피" |

- ### 정적 메모리 스택(Stack) 영역

**스택 영역에는 기본 타입 변수가 할당되고 변수의 실제 값들이 저장** 된다.

**참조 타입의 변수들은 이 스택 영역에서 힙 영역에 생성된 객체들의 주소 값을 저장** 하고 있는다.

객체 안의 메소드의 작업이 종료되면 할당되었던 메모리 공간은 반환되어 비워진다.

- ### 동적 메모리 힙(Heap) 영역

힙 영역에는 객체와 배열이 생성된다.

그리고 `참조 타입` **(배열, 클래스, 인터페이스 등)들이** `이 객체들의 주소`를 `스택 영역`**에 저장한다.**

**기본 타입 변수들과는 다르게 크기가 정해져 있지 않다.**

**프로그램 실행 시 메모리에 동적으로 할당** 된다.

**참조하는 변수가 없으면 자바의 `가비지 컬렉터`가 제거** 한다.

> `가비지 컬렉터(Garbage Collector)` : 메모리의 힙 영역에 할당된 더이상 사용하지 않는 객체를 제거하는 역할

이렇게 객체를 제거하며 메모리가 관리된다.

## 원시 타입과 참조타입 차이

기능적으로 원시 타입과 참조 타입은 크게 2가지 차이가 있다.

### 1. Null 포함 가능 여부

원시타입은 null을 담을 수 없지만, 참조타입은 가능하다.

```java
// 불가능
int i = null;

// 가능
Integer i = null;
```

### 2. 제네릭 타입에서 사용 가능 여부

원시 타입은 제네릭 타입에서 사용할 수 없지만, 참조 타입은 가능하다.

```java
// 불가능
List<int> list;

// 가능
List<Integer> list;
```

### 그러면 굳이 원시타입을 사용하는 이유가 무엇일까?

원시 타입은 null을 다루지도 못하고, 제네릭에 사용할 수도 없다. 그러면 원시타입은 굳이 왜 사용하는 것일까?
`원시 타입이 참조타입과 비교해서 갖는 장점은 '성능'상의 이점이 있다.`

### 1. 접근 속도

![원시타입 장점](https://raw.githubusercontent.com/wlroh/wlroh.github.io/main/assets/images/2022-02-21-java-type-1.png)

**원시 타입은** `'스택' 메모리`**에 값이 존재한다.**

반면에 **참조 타입은 하나의 인스턴스이기 때문에** `'스택' 메모리` **에는 참조값만** 있고, **실제 값은** `'힙' 메모리` **에 존재** 한다.

그리고 **값을 필요로 할 때마다 언박싱 과정을 거쳐야 하니 원시타입과 비교해서 접근 속도가 느려지게 된다.**
예외적으로 엄청 큰 숫자를 복사해야 한다면, 참조값만 넘길 수 있는 참조타입이 좋을 수도 있다.

### 2. 메모리 양

| 원시타입이 사용하는 메모리 | 참조타입이 사용하는 메모리 |
| -------------------------- | -------------------------- |
| boolean = 1bit             | Boolean = 128 bits         |
| byte = 8bit                | Byte = 128 bits            |
| short, char = 16bit        | Short, Charater = 128 bits |
| int, float = 32bit         | Integer, Float = 128 bits  |
| long, double = 64bit       | Longm Double = 196 bits    |

원시 타입보다 **참조 타입이 사용하는 메모리양이 압도적으로 높다.**

따라서 **메모리 사용적으로도 원시 타입이 참조 타입보다 효율적으로 사용** 할 수 있다.
